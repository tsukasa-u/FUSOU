<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FUSOU Formula Mining Dashboard</title>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: system-ui, -apple-system, sans-serif; 
      background: #0f172a; 
      color: #e5e7eb;
      overflow-y: auto;
      min-height: 100vh;
    }
    
    .header {
      background: linear-gradient(135deg, #1e293b, #0f172a);
      border-bottom: 1px solid #1e40af;
      padding: 16px 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .status-badge {
      display: inline-block;
      width: 10px;
      height: 10px;
      background: #ef4444;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    .status-badge.connected { background: #10b981; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    
    .container { display: flex; min-height: calc(100vh - 60px); gap: 12px; }

    .main-panel { flex: 1; display: flex; flex-direction: column; overflow-y: auto; gap: 12px; padding-bottom: 12px; }
    .sub-panel { width: 320px; border-left: 1px solid #1e40af; overflow-y: auto; }
    
    .section { 
      border-bottom: 1px solid #1e40af; 
      padding: 12px;
    }
    
    .section-title { 
      font-size: 12px; 
      font-weight: 600; 
      color: #38bdf8; 
      margin-bottom: 8px;
      text-transform: uppercase;
    }
    
    .stat { background: #1e293b; padding: 8px; border-radius: 4px; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    
    .formula-box {
      background: #111827;
      border: 1px solid #1e40af;
      border-radius: 4px;
      padding: 10px;
      font-family: monospace;
      word-break: break-all;
      min-height: 40px;
    }
    
    .candidate-item {
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 4px;
      padding: 8px;
      margin-bottom: 6px;
    }
    
    .logs-panel {
      flex: 1;
      overflow-y: auto;
      background: #0b1222;
      border: 1px solid #1e40af;
      border-radius: 4px;
      padding: 8px;
      font-family: monospace;
      font-size: 11px;
    }
    
    .log-entry {
      margin: 2px 0;
      padding: 2px 4px;
      border-radius: 2px;
    }
    .log-entry.info { color: #60a5fa; }
    .log-entry.success { color: #10b981; }
    .log-entry.error { color: #ef4444; }
    .log-entry.warning { color: #f59e0b; }
    
    .sub-panel > .section:last-child { border-bottom: none; }
  </style>
</head>
<body>
  <div class="header">
    <h1 style="font-size:18px;">FUSOU Formula Mining Dashboard</h1>
    <div>
      <span class="status-badge" id="status-badge"></span>
      <span id="status-text" style="font-size:13px;">Connecting...</span>
    </div>
  </div>

  <div class="container">
    <div class="main-panel">
      <!-- RMSE Progress -->
      <div class="section">
        <div class="section-title">RMSE Progress</div>
        <div id="rmse-plot" style="height:200px;width:100%;background:#111827;border-radius:4px;"></div>
      </div>
      
      <!-- Dataset Visualization (All Dimensions) -->
      <div class="section">
        <div class="section-title">Dataset Visualization (All Dimensions)</div>
        <div id="dataset-plot" style="height:420px;width:100%;background:#111827;border-radius:4px;overflow: visible;"></div>
        <div id="dataset-info" style="font-size:10px;color:#9ca3af;margin-top:4px;">Loading...</div>
      </div>
      <!-- Clustering (moved to full width) -->
      <div class="section">
        <div class="section-title">Clustering (PCA Projection)</div>
        <div id="clustering-plot" style="height:420px;width:100%;background:#111827;border-radius:4px;"></div>
        <div id="clustering-info" style="font-size:10px;color:#9ca3af;margin-top:4px;">No clustering data</div>
        <div id="clustering-meta" style="font-size:10px;color:#9ca3af;margin-top:4px;"></div>
      </div>

      <!-- Cluster Feature Distributions (All Dimensions) -->
      <div class="section">
        <div class="section-title">Cluster Feature Distributions (All Dimensions)</div>
        <div id="cluster-features-plot" style="height:420px;width:100%;background:#111827;border-radius:4px;"></div>
      </div>        <!-- Per-Cluster Metrics (full width) -->
        <div class="section">
          <div class="section-title">Per-Cluster Metrics</div>
          <div id="per-cluster-list" style="max-height:320px; overflow-y:auto; font-size:11px; display:grid; grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); gap:8px;"></div>
        </div>

      <!-- Solver Metrics -->
      <div class="section">
        <div class="section-title">Solver Metrics</div>
        <div class="grid-2" style="gap:6px;font-size:11px;">
          <div class="stat">
            <div style="color:#9ca3af;">Phase</div>
            <div style="color:#38bdf8;font-weight:bold;" id="phase">Idle</div>
          </div>
          <div class="stat">
            <div style="color:#9ca3af;">Generation</div>
            <div style="color:#38bdf8;font-weight:bold;" id="generation">0</div>
          </div>
          <div class="stat">
            <div style="color:#9ca3af;">RMSE</div>
            <div style="color:#10b981;font-weight:bold;" id="rmse">‚àû</div>
          </div>
          <div class="stat">
            <div style="color:#9ca3af;">Progress</div>
            <div style="color:#f59e0b;font-weight:bold;" id="progress">0%</div>
          </div>
        </div>
      </div>
      
      <!-- Dataset Info -->
      <div class="section">
        <div class="section-title">Dataset</div>
        <div class="grid-2">
          <div class="stat">
            <div class="stat-label">Samples</div>
            <div class="stat-value" id="samples">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Features</div>
            <div class="stat-value" id="features">0</div>
          </div>
        </div>
        <div style="margin-top: 8px; font-size: 10px; color: #9ca3af;" id="target-formula"></div>
      </div>
      
      <!-- Best Formula -->
      <div class="section">
        <div class="section-title">Best Formula</div>
        <div class="formula-box" id="best-formula">Searching...</div>
      </div>
      
      <!-- Top Candidates -->
      <div class="section" style="display: flex; flex-direction: column; max-height: 240px;">
        <div class="section-title">Top Candidates (Top 5)</div>
        <div class="candidates-list" id="candidates" style="flex:1; min-height:80px; max-height:180px; overflow-y:auto;"></div>
      </div>
      
      <!-- Logs -->
      <div class="section" style="flex: 1; min-height: 200px; display: flex; flex-direction: column;">
        <div class="section-title">Event Log</div>
        <div class="logs-panel" id="event-log"></div>
      </div>
    </div>
    
    <!-- Right Panel -->
    <div class="sub-panel">
      <!-- Per-Cluster Metrics -->
      
      <!-- Optimization Results -->
      <div class="section">
        <div class="section-title">Optimization Results</div>
        <div style="font-size: 11px;">
          <div style="margin-bottom: 8px;">
            <div style="color: #9ca3af; margin-bottom: 2px;">Best Error</div>
            <div style="font-size: 14px; color: #10b981; font-weight: bold;" id="best-error-final">‚àû</div>
          </div>
          <div>
            <div style="color: #9ca3af; margin-bottom: 2px;">Total Generations</div>
            <div style="font-size: 14px; color: #38bdf8; font-weight: bold;" id="total-generations">0</div>
          </div>
        </div>
      </div>
      
      <!-- Statistics -->
      <div class="section">
        <div class="section-title">Statistics</div>
        <div style="font-size: 11px;">
          <div style="padding: 4px 0; border-bottom: 1px solid #1e40af;">
            <span style="color: #9ca3af;">Target Error:</span>
            <span style="color: #60a5fa;" id="target-error">-</span>
          </div>
          <div style="padding: 4px 0;">
            <span style="color: #9ca3af;">Samples:</span>
            <span style="color: #60a5fa;" id="sample-count">0</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const wsProto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = wsProto + '//localhost:8765';
    
    const statusBadge = document.getElementById('status-badge');
    const statusText = document.getElementById('status-text');
    const phaseEl = document.getElementById('phase');
    const generationEl = document.getElementById('generation');
    const rmseEl = document.getElementById('rmse');
    const progressEl = document.getElementById('progress');
    const samplesEl = document.getElementById('samples');
    const featuresEl = document.getElementById('features');
    const targetFormulaEl = document.getElementById('target-formula');
    const bestFormulaEl = document.getElementById('best-formula');
    const candidatesEl = document.getElementById('candidates');
    const bestErrorFinalEl = document.getElementById('best-error-final');
    const totalGenerationsEl = document.getElementById('total-generations');
    const targetErrorEl = document.getElementById('target-error');
    const sampleCountEl = document.getElementById('sample-count');
    const eventLogEl = document.getElementById('event-log');
    const clusteringInfoEl = document.getElementById('clustering-info');
    const clusteringMetaEl = document.getElementById('clustering-meta');
    const perClusterListEl = document.getElementById('per-cluster-list');

    function addLog(msg, type = 'info') {
      const entry = document.createElement('div');
      entry.className = 'log-entry ' + type;
      entry.textContent = msg;
      eventLogEl.appendChild(entry);
      while (eventLogEl.children.length > 200) eventLogEl.removeChild(eventLogEl.firstChild);
      eventLogEl.scrollTop = eventLogEl.scrollHeight;
    }

    let ws = null;
    function connect() {
      ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        statusBadge.classList.add('connected');
        statusText.textContent = '‚úì Connected';
        addLog('WebSocket connected', 'success');
      };

      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          handleMessage(msg);
        } catch (err) {
          addLog('Parse error: ' + err.message, 'error');
        }
      };

      ws.onerror = (err) => {
        statusBadge.classList.remove('connected');
        statusText.textContent = '‚úó Error';
        addLog('WebSocket error', 'error');
      };

      ws.onclose = () => {
        statusBadge.classList.remove('connected');
        statusText.textContent = '‚úó Reconnecting...';
        addLog('Disconnected - reconnecting in 3s...', 'warning');
        setTimeout(connect, 3000);
      };
    }

    // --- ÂèØË¶ñÂåñÁî®„Éá„Éº„Çø‰øùÊåÅ ---
    let rmseHistory = [];
    let datasetData = null;
    let clusterData = null;
    let perClusterData = [];

    function handleMessage(msg) {
      const data = msg.data || msg;
      const type = msg.event_type || msg.type;

      // Update solver metrics
      if (data.phase) phaseEl.textContent = data.phase;
      if (data.generation !== undefined) generationEl.textContent = data.generation;
      if (data.best_error !== undefined && data.best_error !== null) {
        const rmseVal = data.best_error === Infinity ? '‚àû' : data.best_error.toFixed(6);
        rmseEl.textContent = rmseVal;
        bestErrorFinalEl.textContent = rmseVal;
        // RMSEÂ±•Ê≠¥„ÇíÊõ¥Êñ∞
        if (data.generation !== undefined && typeof data.best_error === 'number') {
          rmseHistory.push({ x: data.generation, y: data.best_error });
          if (rmseHistory.length > 200) rmseHistory.shift();
          drawRmsePlot();
        }
      }
      if (data.progress !== undefined) progressEl.textContent = (data.progress * 100).toFixed(1) + '%';

      // Update dataset info
      if (data.sample_count !== undefined) {
        samplesEl.textContent = data.sample_count;
        sampleCountEl.textContent = data.sample_count;
      }
      if (data.feature_count !== undefined) featuresEl.textContent = data.feature_count;
      if (data.target_formula) {
        targetFormulaEl.innerHTML = '<strong>Target:</strong> ' + data.target_formula;
      }

      // „Éá„Éº„Çø„Çª„ÉÉ„ÉàÂèØË¶ñÂåñ„Éá„Éº„Çø
      if (data.dataset_scatter) {
        datasetData = data.dataset_scatter;
        drawDatasetPlot();
      }

      // Update formula
      if (data.formula || data.best_formula) {
        bestFormulaEl.textContent = data.formula || data.best_formula;
      }

      // Update candidates
      if (data.top_candidates && Array.isArray(data.top_candidates)) {
        candidatesEl.innerHTML = '';
        data.top_candidates.forEach((c, i) => {
          const div = document.createElement('div');
          div.className = 'candidate-item';
          div.innerHTML = '<div><span class="candidate-rank">#' + (i + 1) + '</span></div>' +
            '<div class="candidate-formula">' + c.formula + '</div>' +
            '<div class="candidate-rmse">RMSE: ' + c.rmse.toFixed(6) + '</div>';
          candidatesEl.appendChild(div);
        });
      }

      // „ÇØ„É©„Çπ„ÇøÂàÜÂ∏É„Éá„Éº„Çø
      if (data.cluster_scatter) {
        clusterData = data.cluster_scatter;
        drawClusteringPlot();
        drawClusterFeatures();
        emitClusterDebug(clusterData);
      }

      if (Array.isArray(data.per_cluster)) {
        perClusterData = data.per_cluster;
        renderPerCluster(perClusterData);
      }

      // Update clustering info
      if (data.cluster_assignments !== undefined && data.cluster_assignments !== null) {
        if (typeof data.cluster_assignments === 'object' && Object.keys(data.cluster_assignments).length > 0) {
          const clusterIds = [...new Set(Object.values(data.cluster_assignments))];
          clusteringInfoEl.innerHTML = '<strong>Clusters:</strong> ' + clusterIds.length + 
            '<br><strong>Samples:</strong> ' + Object.keys(data.cluster_assignments).length;
        } else {
          clusteringInfoEl.textContent = 'No clustering data';
        }
      }

      // Update target error
      if (data.target_error !== undefined) {
        targetErrorEl.textContent = data.target_error.toFixed(6);
      }

      // Update generation counter
      if (data.generation !== undefined) {
        totalGenerationsEl.textContent = data.generation;
      }

      // Log events
      if (type === 'best_formula') {
        addLog('üéØ New best: ' + (data.formula || data.best_formula) + ' (RMSE: ' + (data.rmse?.toFixed(6) || 'N/A') + ')', 'success');
      } else if (type === 'per_cluster_best') {
        if (Array.isArray(data.per_cluster)) {
          perClusterData = data.per_cluster;
          renderPerCluster(perClusterData);
        }
        addLog('üè∑Ô∏è Cluster ' + (data.label ?? '?') + ' best updated (RMSE: ' + (data.rmse?.toFixed(6) || 'N/A') + ')', 'info');
      } else if (type === 'clustering') {
        if (data.cluster_scatter) {
          clusterData = data.cluster_scatter;
          drawClusteringPlot();
          drawClusterFeatures();
          emitClusterDebug(clusterData);
        }
      } else if (type === 'progress') {
        // Don't log every progress update
      } else if (type === 'completed') {
        addLog('‚úÖ Optimization completed!', 'success');
      } else if (type === 'candidate') {
        // Don't log every candidate
      } else if (type === 'init') {
        addLog('üìä Dashboard initialized', 'info');
      }
    }

    function drawRmsePlot() {
      if (rmseHistory.length === 0) return;
      const x = rmseHistory.map(p => p.x);
      const y = rmseHistory.map(p => p.y);
      const trace = {
        x: x,
        y: y,
        mode: 'lines+markers',
        type: 'scatter',
        marker: { color: '#10b981', size: 4 },
        line: { color: '#10b981', width: 2 },
        name: 'RMSE'
      };
      Plotly.newPlot('rmse-plot', [trace], {
        margin: { t: 20, l: 40, r: 10, b: 40 },
        xaxis: { title: 'Generation', color: '#9ca3af', gridcolor: '#1e293b' },
        yaxis: { title: 'RMSE', color: '#9ca3af', gridcolor: '#1e293b' },
        paper_bgcolor: '#111827',
        plot_bgcolor: '#111827',
        font: { color: '#e5e7eb' },
      }, {displayModeBar: false});
    }

    function drawDatasetPlot() {
      if (!datasetData || !datasetData.features || !datasetData.targets) return;
      const features = datasetData.features;
      const targets = datasetData.targets;
      const featureNames = datasetData.feature_names || [];
      const infoEl = document.getElementById('dataset-info');
      
      if (features.length === 0) return;
      const numFeatures = features[0].length;
      const cols = Math.min(numFeatures, 3);
      const rows = Math.ceil(numFeatures / cols);

      // ÂÖ®Ê¨°ÂÖÉ„ÇíË°®Á§∫: ÂêÑÁâπÂæ¥Èáè vs „Çø„Éº„Ç≤„ÉÉ„Éà„ÅÆ„Çµ„Éñ„Éó„É≠„ÉÉ„ÉàÔºàËá™Âãï„Ç∞„É™„ÉÉ„ÉâÔºâ
      const traces = [];
      for (let i = 0; i < numFeatures; i++) {
        const x = features.map(f => f[i]);
        traces.push({
          x: x,
          y: targets,
          mode: 'markers',
          type: 'scatter',
          marker: { color: '#60a5fa', size: 4 },
          name: featureNames[i] || ('F' + i),
          xaxis: 'x' + (i + 1),
          yaxis: 'y' + (i + 1)
        });
      }
      
      const layout = {
        grid: { rows, columns: cols, pattern: 'independent' },
        margin: { t: 30, l: 40, r: 10, b: 40 },
        paper_bgcolor: '#111827',
        plot_bgcolor: '#111827',
        font: { color: '#e5e7eb', size: 9 },
        showlegend: false,
      };
      
      for (let i = 0; i < numFeatures; i++) {
        layout['xaxis' + (i + 1)] = { 
          title: featureNames[i] || ('F' + i), 
          color: '#9ca3af', 
          gridcolor: '#1e293b',
          titlefont: { size: 9 }
        };
        layout['yaxis' + (i + 1)] = { 
          title: i % cols === 0 ? 'Target' : '', 
          color: '#9ca3af', 
          gridcolor: '#1e293b',
          titlefont: { size: 9 }
        };
      }

      // È´ò„Åï„ÇíÊ¨°ÂÖÉÊï∞„Å´Âøú„Åò„Å¶Ëá™ÂãïË™øÊï¥Ôºà1Ë°å„ÅÇ„Åü„Çä ~240pxÔºâ
      const container = document.getElementById('dataset-plot');
      container.style.height = Math.max(320, rows * 240) + 'px';
      Plotly.newPlot('dataset-plot', traces, layout, {displayModeBar: false});
      infoEl.textContent = numFeatures + 'D dataset: all features vs target (' + features.length + ' samples)';
    }

    function drawClusteringPlot() {
      if (!clusterData) {
        return;
      }
      if (!clusterData.features || !clusterData.clusters) {
        return;
      }
      
      const features = clusterData.features;
      const clusters = clusterData.clusters;
      const featureNames = clusterData.feature_names || [];
      
      if (features.length === 0) {
        addLog('Clustering: no features', 'warning');
        return;
      }
      
      const numFeatures = features[0].length;
      
      // ÂãïÁöÑ‰∏ªÊàêÂàÜÂàÜÊûê: ÊúÄÂàù„ÅÆ2Ëª∏„Åß„ÇØ„É©„Çπ„Çø„ÇíÂèØË¶ñÂåñ
      // Calculate means
      let means = new Array(numFeatures).fill(0);
      for (let f of features) {
        for (let i = 0; i < numFeatures; i++) {
          means[i] += f[i];
        }
      }
      for (let i = 0; i < numFeatures; i++) {
        means[i] /= features.length;
      }
      
      // Centered features
      const centered = features.map(f => f.map((v, i) => v - means[i]));
      
      // Covariance matrix (simplified: principal components via SVD approximation)
      // Use first 2 principal directions directly
      let pc1 = new Array(numFeatures).fill(0);
      let pc2 = new Array(numFeatures).fill(0);
      
      // Simple approach: compute variance along each axis as initial PC direction
      for (let i = 0; i < numFeatures; i++) {
        let variance = 0;
        for (let f of centered) {
          variance += f[i] * f[i];
        }
        pc1[i] = Math.sqrt(variance / features.length);
      }
      
      // Normalize
      let norm1 = Math.sqrt(pc1.reduce((a, b) => a + b * b, 0));
      if (norm1 > 0) {
        for (let i = 0; i < numFeatures; i++) {
          pc1[i] /= norm1;
        }
      }
      
      // PC2: orthogonal to PC1
      for (let i = 0; i < numFeatures; i++) {
        pc2[i] = (i === 1) ? 1 : 0;  // Simple orthogonal default
      }
      let dot = pc1.reduce((sum, v, i) => sum + v * pc2[i], 0);
      for (let i = 0; i < numFeatures; i++) {
        pc2[i] -= dot * pc1[i];
      }
      let norm2 = Math.sqrt(pc2.reduce((a, b) => a + b * b, 0));
      if (norm2 > 0) {
        for (let i = 0; i < numFeatures; i++) {
          pc2[i] /= norm2;
        }
      }
      
      // Project onto PC1, PC2
      const projected = centered.map(f => [
        f.reduce((sum, v, i) => sum + v * pc1[i], 0),
        f.reduce((sum, v, i) => sum + v * pc2[i], 0)
      ]);
      
      const uniqueClusters = [...new Set(clusters)];
      
      const traces = uniqueClusters.map(cl => {
        const idx = clusters.map((c, i) => c === cl ? i : -1).filter(i => i !== -1);
        const x = idx.map(i => projected[i][0]);
        const y = idx.map(i => projected[i][1]);
        return {
          x: x,
          y: y,
          mode: 'markers',
          type: 'scatter',
          marker: { size: 7 },
          name: 'Cluster ' + cl
        };
      });
      
      Plotly.newPlot('clustering-plot', traces, {
        margin: { t: 20, l: 40, r: 10, b: 40 },
        xaxis: { title: 'PC1', color: '#9ca3af', gridcolor: '#1e293b' },
        yaxis: { title: 'PC2', color: '#9ca3af', gridcolor: '#1e293b' },
        paper_bgcolor: '#111827',
        plot_bgcolor: '#111827',
        font: { color: '#e5e7eb' },
      }, {displayModeBar: false});
      addLog('Clustering plot updated: ' + uniqueClusters.length + ' clusters (PCA projection)', 'info');
    }

    function emitClusterDebug(clusterScatter) {
      if (!clusterScatter || !clusterScatter.meta) return;
      const m = clusterScatter.meta;
      const text = `points=${m.points ?? '?'} / clusters=${m.clusters ?? '?'} / features_per_sample=${m.features_per_sample ?? '?'} / assignments=${m.assignments ?? '?'}`;
      clusteringMetaEl.textContent = text;
      addLog('Cluster debug: ' + text, 'info');
      console.debug('Cluster debug meta', m);
    }

    function drawClusterFeatures() {
      // Draw box plots or bar charts showing feature distributions per cluster
      if (!clusterData || !clusterData.features || !clusterData.clusters) {
        return;
      }
      
      const features = clusterData.features;
      const clusters = clusterData.clusters;
      const featureNames = clusterData.feature_names || [];
      const numFeatures = features[0].length;
      
      const uniqueClusters = [...new Set(clusters)];
      
      // For each feature, create a box plot showing distribution across clusters
      const traces = [];
      for (let f = 0; f < numFeatures; f++) {
        for (let cl of uniqueClusters) {
          const idx = clusters.map((c, i) => c === cl ? i : -1).filter(i => i !== -1);
          const values = idx.map(i => features[i][f]);
          traces.push({
            y: values,
            name: 'Cluster ' + cl + ' - ' + (featureNames[f] || 'F' + f),
            type: 'box',
            boxmean: 'sd'
          });
        }
      }
      
      Plotly.newPlot('cluster-features-plot', traces, {
        margin: { t: 20, l: 40, r: 10, b: 40 },
        yaxis: { title: 'Feature Value', color: '#9ca3af', gridcolor: '#1e293b' },
        paper_bgcolor: '#111827',
        plot_bgcolor: '#111827',
        font: { color: '#e5e7eb', size: 10 },
        showlegend: true
      }, {displayModeBar: false});
    }

    function renderPerCluster(perCluster) {
      if (!perClusterListEl) return;
      perClusterListEl.innerHTML = '';
      if (!perCluster || perCluster.length === 0) {
        perClusterListEl.textContent = 'No per-cluster metrics';
        return;
      }
      const sorted = [...perCluster].sort((a, b) => String(a.label).localeCompare(String(b.label)));
      sorted.forEach(item => {
        const row = document.createElement('div');
        row.style.border = '1px solid #1e293b';
        row.style.borderRadius = '4px';
        row.style.padding = '6px';
        row.innerHTML = `
          <div style="display:flex; justify-content:space-between;">
            <span style="color:#38bdf8; font-weight:600;">${item.label ?? 'N/A'}</span>
            <span style="color:#9ca3af;">Gen ${item.generation ?? 0}</span>
          </div>
          <div style="color:#10b981; font-weight:bold;">RMSE: ${item.rmse?.toFixed ? item.rmse.toFixed(6) : item.rmse}</div>
          <div style="color:#e5e7eb; font-family:monospace; margin-top:4px; word-break:break-all;">${item.formula ?? ''}</div>
        `;
        perClusterListEl.appendChild(row);
      });
    }

    addLog('Starting dashboard...', 'info');
    connect();
  </script>
</body>
</html>
